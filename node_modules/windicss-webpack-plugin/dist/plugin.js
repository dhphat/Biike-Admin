"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const plugin_utils_1 = require("@windicss/plugin-utils");
const upath_1 = require("upath");
const webpack_virtual_modules_1 = __importDefault(require("webpack-virtual-modules"));
const constants_1 = require("./constants");
const debug_1 = __importDefault(require("./debug"));
const loadersPath = upath_1.resolve(__dirname, 'loaders');
const pitcher = upath_1.resolve(loadersPath, 'pitcher.js');
const transformCSSLoader = upath_1.resolve(loadersPath, 'transform-css.js');
const transformTemplateLoader = upath_1.resolve(loadersPath, 'transform-template.js');
const virtualModuleLoader = upath_1.resolve(loadersPath, 'virtual-module.js');
class WindiCSSWebpackPlugin {
    constructor(options = {}) {
        // @todo validate options
        this.options = Object.assign({
            // default virtual module path will be the root
            virtualModulePath: '',
        }, options);
    }
    apply(compiler) {
        var _a, _b, _c, _d;
        const root = (_d = (_a = this.options.root) !== null && _a !== void 0 ? _a : (_c = (_b = compiler.options.resolve) === null || _b === void 0 ? void 0 : _b.alias) === null || _c === void 0 ? void 0 : _c['~']) !== null && _d !== void 0 ? _d : compiler.context;
        // Fix possibly undefined issues
        if (!compiler.options.module || !compiler.options.module.rules)
            return;
        if (!compiler.options.resolve)
            compiler.options.resolve = {};
        // setup alias
        compiler.options.resolve.alias = Object.assign(Object.assign(Object.assign(Object.assign({}, compiler.options.resolve.alias), { 
            // add windi.css alias
            [upath_1.join(this.options.virtualModulePath, constants_1.MODULE_ID)]: upath_1.resolve(compiler.context, constants_1.MODULE_ID_VIRTUAL_MODULES[0]) }), constants_1.MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
            // @ts-ignore
            map[upath_1.join(this.options.virtualModulePath, key)] = upath_1.resolve(compiler.context, key);
            return map;
        }, {})), constants_1.MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
            // @ts-ignore
            map[upath_1.join(this.options.virtualModulePath, key.replace('virtual:', ''))] = upath_1.resolve(compiler.context, key);
            return map;
        }, {}));
        debug_1.default.plugin('options', this.options);
        // Replace the css-loader with one that uses importLoaders, see https://webpack.js.org/loaders/css-loader/#importloaders
        // Note: This is experimental and may break something
        compiler.options.module.rules = compiler.options.module.rules.map((rule) => {
            if (!rule.use || !(rule.use instanceof Array))
                return rule;
            rule.use = rule.use.map((use) => {
                if (use === 'css-loader') {
                    return {
                        loader: 'css-loader',
                        options: {
                            // postcss & windi
                            importLoaders: 2,
                        },
                    };
                }
                return use;
            });
            return rule;
        });
        const shouldExcludeResource = (resource) => 
        // can't contain the windi virtual module names
        constants_1.MODULE_ID_VIRTUAL_TEST.test(resource);
        /*
         * Pitch the loaders so we run transformations at the right time
         */
        compiler.options.module.rules.push({
            include(resource) {
                var _a;
                if (shouldExcludeResource(resource))
                    return false;
                return Boolean((_a = compiler.$windyCSSService) === null || _a === void 0 ? void 0 : _a.isDetectTarget(resource));
            },
            enforce: 'post',
            use: [{
                    loader: pitcher,
                }],
        });
        /*
         * Transform groups within all detect targets.
         *
         * e.g. hover:(bg-teal-900 rounded-full) -> hover:bg-teal-900 hover:rounded-full
         */
        compiler.options.module.rules.push({
            include(resource) {
                var _a;
                if (shouldExcludeResource(resource))
                    return false;
                return Boolean((_a = compiler.$windyCSSService) === null || _a === void 0 ? void 0 : _a.isDetectTarget(resource));
            },
            use: [{
                    loader: transformTemplateLoader,
                }],
        });
        compiler.options.module.rules.push({
            include(resource) {
                var _a;
                if (shouldExcludeResource(resource))
                    return false;
                return Boolean((_a = compiler.$windyCSSService) === null || _a === void 0 ? void 0 : _a.isCssTransformTarget(resource));
            },
            use: [{
                    loader: transformCSSLoader,
                }],
        });
        /*
         * Virtual module loader
         */
        compiler.options.module.rules.push({
            include(resource) {
                return constants_1.MODULE_ID_VIRTUAL_TEST.test(resource);
            },
            enforce: 'pre',
            use: [{
                    loader: virtualModuleLoader,
                }],
        });
        /*
        * Add the windycss config file as a dependency so that the watcher can handle updates to it.
        */
        compiler.hooks.afterCompile.tap(constants_1.NAME, (compilation) => {
            if (compiler.$windyCSSService) {
                let hasConfig = false;
                // add watcher for the config path
                for (const name of plugin_utils_1.defaultConfigureFiles) {
                    const tryPath = upath_1.resolve(root, name);
                    if (fs_1.existsSync(tryPath)) {
                        debug_1.default.plugin('config dependency at', tryPath);
                        compilation.fileDependencies.add(tryPath);
                        hasConfig = true;
                    }
                }
                // add watcher for missing dependencies
                if (!hasConfig) {
                    for (const name of plugin_utils_1.defaultConfigureFiles) {
                        const path = upath_1.resolve(root, name);
                        debug_1.default.plugin('setting watcher for config creation', path);
                        compilation.missingDependencies.add(path);
                    }
                }
            }
        });
        const virtualModules = new webpack_virtual_modules_1.default(constants_1.MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
            // @ts-ignore
            map[upath_1.join(this.options.virtualModulePath, key)] = `/* ${key}(boot) */`;
            return map;
        }, {}));
        virtualModules.apply(compiler);
        /*
        * Triggered when the watcher notices a file is updated. We keep track of the updated (dirty) file and
        * create an invalidated on our virtual module.
        */
        let hmrId = 0;
        compiler.hooks.invalid.tap(constants_1.NAME, (resource) => {
            if (!resource)
                resource = 'all-modules';
            // make sure service is available and file is valid
            if (!compiler.$windyCSSService || shouldExcludeResource(resource))
                return;
            const skipInvalidation = compiler.$windyCSSService.dirty.has(resource)
                || (resource !== 'all-modules' && !compiler.$windyCSSService.isDetectTarget(resource) && resource !== compiler.$windyCSSService.configFilePath);
            debug_1.default.plugin('file update', resource, `skip:${skipInvalidation}`);
            if (skipInvalidation)
                return;
            // Add dirty file so the loader can process it
            compiler.$windyCSSService.dirty.add(resource);
            // Trigger a change to the virtual module
            const moduleUpdateId = hmrId++;
            constants_1.MODULE_ID_VIRTUAL_MODULES.forEach((virtualModulePath) => {
                var _a;
                let virtualModuleContent = '';
                const match = virtualModulePath.match(constants_1.MODULE_ID_VIRTUAL_TEST);
                if (match) {
                    const layer = match[1] || 'all';
                    if (compiler.$windyCSSService && compiler.$windyCSSService.virtualModules.has(layer))
                        virtualModuleContent = (_a = compiler.$windyCSSService.virtualModules.get(layer)) !== null && _a !== void 0 ? _a : '';
                }
                virtualModules.writeModule(upath_1.join(this.options.virtualModulePath, virtualModulePath), 
                // Need to write a dynamic string which will mark the file as modified
                `/* windicss(hmr:${moduleUpdateId}:${resource}) */\n${virtualModuleContent}`);
            });
        });
        // Make windy service available to the loader
        const initWindyCSSService = async () => {
            var _a;
            if (!compiler.$windyCSSService) {
                const utils = (_a = this.options.utils) !== null && _a !== void 0 ? _a : plugin_utils_1.createUtils(this.options, {
                    root,
                    name: constants_1.NAME,
                });
                compiler.$windyCSSService = Object.assign(utils, {
                    root,
                    virtualModules: new Map(),
                    dirty: new Set(),
                });
                // Scans all files and builds initial css
                // wrap in a try catch
                try {
                    await compiler.$windyCSSService.init();
                }
                catch (e) {
                    compiler.$windyCSSService.initException = e;
                }
            }
        };
        compiler.hooks.thisCompilation.tap(constants_1.NAME, (compilation) => {
            if (!compiler.$windyCSSService)
                return;
            // give the init exception to the compilation so that the user can see there was an issue
            if (compiler.$windyCSSService.initException) {
                compilation.errors.push(compiler.$windyCSSService.initException);
                compiler.$windyCSSService.initException = undefined;
            }
            compilation.hooks.childCompiler.tap(constants_1.NAME, (childCompiler) => {
                childCompiler.$windyCSSService = compiler.$windyCSSService;
            });
        });
        compiler.hooks.beforeCompile.tapPromise(constants_1.NAME, async () => {
            await initWindyCSSService();
        });
        compiler.hooks.watchRun.tapPromise(constants_1.NAME, async () => {
            await initWindyCSSService();
        });
    }
}
exports.default = WindiCSSWebpackPlugin;
